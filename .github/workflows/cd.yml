name: Continuous Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
        - staging
        - production

jobs:
  # First, run all the tests
  test:
    uses: ./.github/workflows/reusable-tests.yml

  # Build and push Docker images
  build-and-push:
    runs-on: ubuntu-latest
    needs: test
    strategy:
      matrix:
        service: [surfshark, qbittorrent, slskd, kopia, prometheus, grafana, loki, promtail, alertmanager, thanos-sidecar, thanos-query, node-exporter, cadvisor, smartctl-exporter, netdata, nextcloud, nextcloud-db, gitea, gitea-db, portainer, uptime-kuma, dozzle, nginx-proxy-manager, homepage]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Extract service info
        id: service_info
        run: |
          # Extract image name from docker-compose.yml for each service
          IMAGE=$(grep -A 20 "services:" docker-compose.yml | grep -A 15 "  ${{ matrix.service }}:" | grep "image:" | head -1 | awk '{print $2}')
          if [ -n "$IMAGE" ]; then
            echo "image=$IMAGE" >> $GITHUB_OUTPUT
            echo "Found image $IMAGE for service ${{ matrix.service }}"
          else
            echo "Could not find image for service ${{ matrix.service }}"
            exit 1
          fi
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to Docker Hub
        if: ${{ secrets.DOCKER_USERNAME && secrets.DOCKER_PASSWORD }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Build and push Docker image (if it's a custom image)
        run: |
          IMAGE_NAME="${{ steps.service_info.outputs.image }}"
          echo "Processing image: $IMAGE_NAME"
          # Only build custom images, skip public images
          # For this stack, most services use public images, so this step is just to verify
          echo "Image $IMAGE_NAME is a public image, no build required"

  # Deploy to staging automatically
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [test, build-and-push]
    if: github.event.inputs.environment == 'staging'
    environment:
      name: staging
      url: ${{ vars.STAGING_BASE_URL || 'https://staging.example.com' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup SSH key for staging
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_PRIVATE_KEY }}
      - name: Configure SSH for staging
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ vars.STAGING_HOST || 'staging-server' }} >> ~/.ssh/known_hosts
      - name: Deploy to staging
        run: |
          echo "ðŸš€ Deploying to staging environment..."
          chmod +x deploy.sh
          ./deploy.sh staging \
            --server "${{ vars.STAGING_HOST || secrets.STAGING_HOST }}" \
            --user "${{ vars.STAGING_USER || secrets.STAGING_USER || 'root' }}" \
            --dir "${{ vars.STAGING_DIR || secrets.STAGING_DIR || '/opt/potatostack' }}" \
            --ssh-key ~/.ssh/id_rsa

      - name: Verify deployment (optional)
        run: |
          # In a real deployment, you would ping your staging endpoint to verify it's running
          # This is just a placeholder for actual health checks
          echo "ðŸ” Verifying staging deployment status..."
          echo "âœ… Staging deployment verification completed"

  # Deploy to production requires manual approval
  deploy-production:
    runs-on: ubuntu-latest
    needs: [test, build-and-push]
    if: github.event.inputs.environment == 'production'
    environment:
      name: production
      url: ${{ vars.PRODUCTION_BASE_URL || 'https://production.example.com' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup SSH key for production
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}
      - name: Configure SSH for production
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ vars.PRODUCTION_HOST || 'production-server' }} >> ~/.ssh/known_hosts
      - name: Deploy to production
        run: |
          echo "ðŸš€ Deploying to production environment..."
          chmod +x deploy.sh
          ./deploy.sh production \
            --server "${{ vars.PRODUCTION_HOST || secrets.PRODUCTION_HOST }}" \
            --user "${{ vars.PRODUCTION_USER || secrets.PRODUCTION_USER || 'root' }}" \
            --dir "${{ vars.PRODUCTION_DIR || secrets.PRODUCTION_DIR || '/opt/potatostack' }}" \
            --ssh-key ~/.ssh/id_rsa

      - name: Verify deployment (optional)
        run: |
          # In a real deployment, you would ping your production endpoint to verify it's running
          # This is just a placeholder for actual health checks
          echo "ðŸ” Verifying production deployment status..."
          echo "âœ… Production deployment verification completed"

  # Send notification on success or failure
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() # Always run this job
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [[ "${{ needs.deploy-staging.result }}" == "success" ]] || [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            echo "status=SUCCESS" >> $GITHUB_OUTPUT
          elif [[ "${{ needs.deploy-staging.result }}" == "failure" ]] || [[ "${{ needs.deploy-production.result }}" == "failure" ]]; then
            echo "status=FAILURE" >> $GITHUB_OUTPUT
          else
            echo "status=UNKNOWN" >> $GITHUB_OUTPUT
          fi
      - name: Send Slack notification
        if: ${{ secrets.SLACK_WEBHOOK_URL }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "Deployment to ${{ github.event.inputs.environment }} ${{ steps.status.outputs.status }}. See details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
